<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP8266 Simon Says</title>
    
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    
    <h1>ESP8266 Simon Says</h1>
    
    <h2 id="game-status">Press Start to begin!</h2>
    
    <button id="start-button" disabled>Start Game</button>
    
    <div id="game-container">
        </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    
    <script>
        // --- Establish Connection ---
        // This 'io()' function now exists because the script loaded correctly.
        const socket = io();
        
        // --- Get Control Elements ---
        // Get references to the HTML elements we need to control
        const gameContainer = document.getElementById('game-container');
        const statusText = document.getElementById('game-status');
        const startButton = document.getElementById('start-button');

        // --- Color Mapping ---
        // Maps the color names from the server (e.g., 'red')
        // to their CSS hex codes for a "resting" (dim) state
        // and a "vibrant" (flash) state.
        const colorMap = {
            'red': { resting: '#8b0000', vibrant: '#ff0000' },
            'green': { resting: '#006400', vibrant: '#00ff00' },
            'yellow': { resting: '#8B8000', vibrant: '#ffff00' },
            'blue': { resting: '#00008b', vibrant: '#0000ff' }
        };
        // A fallback color pair for any unknown boards
        const defaultColor = { resting: '#444', vibrant: '#eee' };


        // --- SocketIO Listeners ---

        // Runs when the browser successfully connects to the server
        socket.on('connect', () => {
            console.log('Successfully connected to server WebSocket.');
        });

        // Runs if the browser gets disconnected from the server
        socket.on('disconnect', () => {
            console.log('Disconnected from server WebSocket.');
        });
        
        // This listener fires when the server wants to confirm a *player's*
        // physical sensor hit. 'data' is { ..., chipId: ..., distance: ... }
        socket.on('new_message', (data) => {
            console.log('Trigger message received:', data);
            
            // Only flash if the server sent a chipId
            if (data.chipId) {
                // Flash the square corresponding to this chipId
                flashSquare(data.chipId);
            }
        });
        
        // This listener fires when the server is *showing* the sequence
        // and wants to flash a square as part of the demo.
        socket.on('show_flash', (data) => {
            // 'data' is { chipId: ... }
            console.log('Show flash command received:', data);
            if (data.chipId) {
                // Flash the square corresponding to this chipId
                flashSquare(data.chipId);
            }
        });

        // This listener builds the game board.
        // It receives an object of 'boards' like: { "9072791": "green", ... }
        socket.on('update_boards', (boards) => {
            console.log('Updating boards:', boards);
            
            // Clear any old squares from the container
            gameContainer.innerHTML = '';
            
            // Get a count of how many boards are in the object
            const boardCount = Object.keys(boards).length;

            // Loop through each board (by chipId) in the 'boards' object
            for (const chipId in boards) {
                const colorName = boards[chipId]; // e.g., 'green'
                // Get the color pair, or use the default if name isn't found
                const colors = colorMap[colorName] || defaultColor; 
                
                // Create a new <div> element
                const square = document.createElement('div');
                
                // Set the element's ID to the chipId (e.g., id="9072791")
                // This is how we find it later to flash it
                square.id = chipId;
                
                // Add the base CSS class for styling
                square.className = 'status-square';
                
                // Set its initial (resting) background color
                square.style.backgroundColor = colors.resting;
                
                // Store the vibrant and resting colors on the element's
                // 'dataset' for the flashSquare function to use
                square.dataset.restingColor = colors.resting;
                square.dataset.vibrantColor = colors.vibrant;
                
                // Add a text label inside the square (e.g., "Green")
                const label = document.createElement('span');
                label.textContent = colorName.charAt(0).toUpperCase() + colorName.slice(1);
                square.appendChild(label);
                
                // Add the fully built square to the game container
                gameContainer.appendChild(square);
            }
            
            // --- LOGIC FIX ---
            // Only enable the 'Start Game' button if there is
            // at least one board connected and displayed.
            if (boardCount > 0) {
                // Enable the button only if it's currently disabled
                // and the game isn't over.
                if (startButton.disabled) {
                    const gameStatus = statusText.textContent;
                    // Only enable if it's a "fresh" page, not a "Game Over" screen
                    if (!gameStatus.includes("Game Over")) {
                         startButton.disabled = false;
                         statusText.textContent = 'Ready to play!';
                    }
                }
            } else {
                // If no boards are connected, keep the button disabled
                startButton.disabled = true;
                statusText.textContent = 'Waiting for boards to connect...';
            }
        });

        // This listener handles all game state messages from the server
        socket.on('game_update', (data) => {
            // 'data' is { status: '...', level: '...', reason: '...', message: '...' }
            console.log('Game update:', data);

            // A 'switch' statement to handle different game statuses
            switch(data.status) {
                case 'SHOWING':
                    // Server is showing the sequence
                    statusText.textContent = `Level ${data.level}! Watch...`;
                    startButton.disabled = true;
                    break;
                case 'PLAYER_TURN':
                    // It's the player's turn to repeat the sequence
                    statusText.textContent = `Level ${data.level}: Your Turn!`;
                    startButton.disabled = true;
                    break;
                case 'LEVEL_COMPLETE':
                    // Player finished the level successfully
                    statusText.textContent = `Level ${data.level} Complete!`;
                    startButton.disabled = true;
                    break;
                case 'GAME_OVER':
                    // Player lost
                    let reason = (data.reason === 'timeout') ? 'You ran out of time!' : 'Wrong move!';
                    statusText.textContent = `Game Over! (Level ${data.level}) ${reason}`;
                    // Re-enable the button to allow starting a new game
                    startButton.disabled = false;
                    startButton.textContent = 'Play Again?';
                    break;
                case 'CORRECT_INPUT':
                    // Player hit one board correctly, but not the whole sequence yet
                    console.log('Correct input, waiting for next...');
                    break;
                case 'ERROR':
                    // Server sent an error (e.g., "No boards connected")
                    statusText.textContent = data.message;
                    // Re-enable the button (it would be disabled if this was a
                    // 'no boards' error)
                    startButton.disabled = false;
                    break;
            }
        });
        
        // --- Click Handlers ---
        
        // Add a click event listener to the 'Start Game' button
        startButton.addEventListener('click', () => {
            console.log('Start button clicked.');
            // Send the 'start_game' event to the server
            socket.emit('start_game');
            // Update the UI immediately
            statusText.textContent = 'Get Ready...';
            startButton.disabled = true;
        });
        
        // --- Helper Functions ---
        
        /**
         * Finds a square by its chipId and runs the flash-and-fade animation.
         */
        function flashSquare(chipId) {
            // Find the HTML element with the matching ID
            const square = document.getElementById(chipId);
            
            // Do nothing if the square doesn't exist on the page
            if (!square) {
                console.warn(`Tried to flash non-existent square: ${chipId}`);
                return;
            }
            
            // Get the square's unique colors, which we stored earlier
            // in the 'dataset'
            const restingColor = square.dataset.restingColor;
            const vibrantColor = square.dataset.vibrantColor;

            // 1. Remove any CSS transition, and set the color to
            //    the VIBRANT color immediately
            square.style.transition = 'none';
            square.style.backgroundColor = vibrantColor;

            // 2. Wait a tiny moment (100ms), then re-apply a CSS transition
            //    and set the *target* color to fade back to the RESTING color.
            setTimeout(() => {
                // This transition makes it fade back over 1 second
                square.style.transition = 'background-color 1s ease';
                square.style.backgroundColor = restingColor;
            }, 100); 
        }

    </script>
</body>
</html>